$NetBSD$

--- lib/MC/MCAsmStreamer.cpp.orig	Thu Aug 26 11:47:34 2010
+++ lib/MC/MCAsmStreamer.cpp
@@ -250,6 +250,7 @@ void MCAsmStreamer::EmitAssignment(MCSymbol *Symbol, c
 
 void MCAsmStreamer::EmitSymbolAttribute(MCSymbol *Symbol,
                                         MCSymbolAttr Attribute) {
+#ifdef __minix
   switch (Attribute) {
   case MCSA_Invalid: assert(0 && "Invalid symbol attribute");
   case MCSA_ELF_TypeFunction:    /// .type _foo, STT_FUNC  # aka @function
@@ -275,6 +276,50 @@ void MCAsmStreamer::EmitSymbolAttribute(MCSymbol *Symb
   case MCSA_Global: // .globl/.global
     OS << MAI.getGlobalDirective();
     break;
+  case MCSA_Hidden:         OS << "\t// .hidden\t";          break;
+  case MCSA_IndirectSymbol: OS << "\t// .indirect_symbol\t"; break;
+  case MCSA_Internal:       OS << "\t// .internal\t";        break;
+  case MCSA_LazyReference:  OS << "\t// .lazy_reference\t";  break;
+  case MCSA_Local:          OS << "\t// .local\t";           break;
+  case MCSA_NoDeadStrip:    OS << "\t// .no_dead_strip\t";   break;
+  case MCSA_PrivateExtern:  OS << "\t// .private_extern\t";  break;
+  case MCSA_Protected:      OS << "\t// .protected\t";       break;
+  case MCSA_Reference:      OS << "\t// .reference\t";       break;
+  case MCSA_Weak:           OS << "\t// .weak\t";            break;
+  case MCSA_WeakDefinition: OS << "\t// .weak_definition\t"; break;
+      // .weak_reference
+  case MCSA_WeakReference:  OS << "\t// .weak_reference"; break;
+  //case MCSA_WeakReference:  OS << MAI.getWeakRefDirective(); break;
+  }
+
+  OS << *Symbol;
+  EmitEOL();
+#else
+  switch (Attribute) {
+  case MCSA_Invalid: assert(0 && "Invalid symbol attribute");
+  case MCSA_ELF_TypeFunction:    /// .type _foo, STT_FUNC  # aka @function
+  case MCSA_ELF_TypeIndFunction: /// .type _foo, STT_GNU_IFUNC
+  case MCSA_ELF_TypeObject:      /// .type _foo, STT_OBJECT  # aka @object
+  case MCSA_ELF_TypeTLS:         /// .type _foo, STT_TLS     # aka @tls_object
+  case MCSA_ELF_TypeCommon:      /// .type _foo, STT_COMMON  # aka @common
+  case MCSA_ELF_TypeNoType:      /// .type _foo, STT_NOTYPE  # aka @notype
+    assert(MAI.hasDotTypeDotSizeDirective() && "Symbol Attr not supported");
+    OS << "\t.type\t" << *Symbol << ','
+       << ((MAI.getCommentString()[0] != '@') ? '@' : '%');
+    switch (Attribute) {
+    default: assert(0 && "Unknown ELF .type");
+    case MCSA_ELF_TypeFunction:    OS << "function"; break;
+    case MCSA_ELF_TypeIndFunction: OS << "gnu_indirect_function"; break;
+    case MCSA_ELF_TypeObject:      OS << "object"; break;
+    case MCSA_ELF_TypeTLS:         OS << "tls_object"; break;
+    case MCSA_ELF_TypeCommon:      OS << "common"; break;
+    case MCSA_ELF_TypeNoType:      OS << "no_type"; break;
+    }
+    EmitEOL();
+    return;
+  case MCSA_Global: // .globl/.global
+    OS << MAI.getGlobalDirective();
+    break;
   case MCSA_Hidden:         OS << "\t.hidden\t";          break;
   case MCSA_IndirectSymbol: OS << "\t.indirect_symbol\t"; break;
   case MCSA_Internal:       OS << "\t.internal\t";        break;
@@ -293,6 +338,7 @@ void MCAsmStreamer::EmitSymbolAttribute(MCSymbol *Symb
 
   OS << *Symbol;
   EmitEOL();
+#endif
 }
 
 void MCAsmStreamer::EmitSymbolDesc(MCSymbol *Symbol, unsigned DescValue) {
@@ -328,12 +374,14 @@ void MCAsmStreamer::EmitELFSize(MCSymbol *Symbol, cons
 void MCAsmStreamer::EmitCommonSymbol(MCSymbol *Symbol, uint64_t Size,
                                      unsigned ByteAlignment) {
   OS << "\t.comm\t" << *Symbol << ',' << Size;
+#ifndef __minix
   if (ByteAlignment != 0) {
     if (MAI.getCOMMDirectiveAlignmentIsInBytes())
       OS << ',' << ByteAlignment;
     else
       OS << ',' << Log2_32(ByteAlignment);
   }
+#endif
   EmitEOL();
 }
 
